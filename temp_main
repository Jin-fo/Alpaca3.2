from head import *
from module.client import Account, DataType, CurrencyType
from module.stats import Stats
from module.model import Model, LSTM


class MenuOption(Enum):
    """Menu options for the application"""
    DISPLAY_INFO = "0"
    START_STREAM = "1"
    STOP_STREAM = "2"
    FILE_HISTORICAL = "3"
    EXIT = "4"


@dataclass
class AppConfig:
    """Application configuration"""
    api_key: str = "PKE1B8WAV2KJ324ZKQKC"
    secret_key: str = "Ro7nFRclHQekQSf5Tt3zbpJAr9AaXhQ7r67sJJDy"
    paper: bool = True
    symbols: List[str] = None


    data_type: DataType = DataType.BARS


    def __post_init__(self):
        if self.symbols is None:
            self.symbols = ["BTC/USD", "ETH/USD", "NVDA", "AAPL"]
    
    @property
    def client_config(self) -> Dict[str, str]:
        return {
            "API_KEY": self.api_key,
            "SECRET_KEY": self.secret_key,
            "paper": self.paper
        }
    
    @property
    def time_interval(self) -> Dict:
        return {
            "range": {"day": 7, "hour": 0, "minute": 0},
            "step": {"day": 0, "hour": 0, "minute": 5}
        }


class Application:
    """Market data streaming and analysis application"""
    
    def __init__(self, config: Optional[AppConfig] = None):
        self.config = config or AppConfig()
        self.account = Account(self.config.client_config, "Paper Account")

    async def fetch_historical(self) -> None:
        """Fetch historical data for focused symbols"""
        print("[+] Fetching historical data...")
        
        tasks = [
            self.account.fetch_historical(CurrencyType.CRYPTO, self.config.data_type, self.config.time_interval),
            self.account.fetch_historical(CurrencyType.STOCK, self.config.data_type, self.config.time_interval),
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        crypto_data, stock_data = results
        
        self.file_historical("crypto", crypto_data)
        self.file_historical("stock", stock_data)
#-------------------------------------------------------------------------------
    async def fetch_historical(self) -> None:
        """Fetch historical data for focused symbols"""
        print("[+] Fetching historical data...")
        
        tasks = [
            self.account.crypto_history(self.config.data_type, self.config.time_interval),
            self.account.stock_history(self.config.data_type, self.config.time_interval)
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        crypto_data, stock_data = results
        
        self.file_historical("crypto", crypto_data)
        self.file_historical("stock", stock_data)

    def file_historical(self, currency: str, symbol_data) -> None:
        """Save individual symbol data to CSV files"""
        if isinstance(symbol_data, Exception):
            print(f"[!] Error fetching {currency} data: {symbol_data}")
            return
            
        if not symbol_data:
            return
            
        total_records = 0
        for symbol, data in symbol_data.items():
            if not data.empty:
                stats = Stats(symbol)
                stats.write(data)
                total_records += len(data)
        
        if total_records > 0:
            print(f"[o] {currency.title()}: {total_records} total records across {len(symbol_data)} symbols")
#-------------------------------------------------------------------------------
    async def start_streams(self) -> None:
        """Start streaming for focused symbols"""
        if self.account.active_streams:
            print("[!] Stream already running!")
            return

        stream_tasks = [
            self.account.crypto_stream(self.config.data_type, self.account.focused["crypto"]),
            self.account.stock_stream(self.config.data_type, self.account.focused["stock"])
        ]
        
        await asyncio.gather(*stream_tasks, return_exceptions=True)
    def file_stream(self, currency: str, symbol_data) -> None:
        """Save individual symbol data to CSV files"""
        if isinstance(symbol_data, Exception):
            print(f"[!] Error fetching {currency} data: {symbol_data}")
            return
            
            
#-------------------------------------------------------------------------------
    async def stop_streams(self) -> None:
        """Stop all active streams"""
        if not self.account.active_streams:
            print("[!] No streams to stop")
            return
            
        await self.account.stop_streams()
#-------------------------------------------------------------------------------
    async def exit_application(self) -> str:
        """Gracefully exit the application"""
        await self.stop_streams()
        print("[o] Goodbye!")
        return "exit"
#-------------------------------------------------------------------------------
    async def display_account_info(self) -> None:
        """Display account information"""
        print("-" * 30)
        self.account.account_info()
        print("-" * 30)
#-------------------------------------------------------------------------------
class Menu(Application):
    """Menu for the application"""
    def __init__(self, config: Optional[AppConfig] = None):
        super().__init__(config)
        self.setup_menu_actions()
#-------------------------------------------------------------------------------
    def setup_menu_actions(self) -> None:
        """Setup menu action mappings"""
        self.menu_actions: Dict[str, Tuple[str, Callable]] = {
            MenuOption.DISPLAY_INFO.value: ("Display Info", self.display_account_info),
            MenuOption.START_STREAM.value: ("Start Stream", self.start_streams),
            MenuOption.STOP_STREAM.value: ("Stop Stream", self.stop_streams),
            MenuOption.FILE_HISTORICAL.value: ("File Historical", self.fetch_historical),
            MenuOption.EXIT.value: ("Exit", self.exit_application)
        }
#-------------------------------------------------------------------------------
    def display_menu(self) -> None:
        """Display the application menu"""
        status = self._get_stream_status()
        
        print(f"\n┌─────────────────────────────┐")
        print(f"     STATUS: {status:<12} ")
        print(f"├─────────────────────────────┤")
        for option, (description, _) in self.menu_actions.items():
            print(f"│ {option}. {description:<24} │")
        print(f"└─────────────────────────────┘")

    def _get_stream_status(self) -> str:
        """Get current streaming status"""
        self.account.get_stream_status()
        active_count = len(self.account.active_streams)
        
        if active_count == 0:
            return "STOPPED"
        
        crypto_count = len(self.account.focused["crypto"]) if self.account.focused["crypto"] else 0
        stock_count = len(self.account.focused["stock"]) if self.account.focused["stock"] else 0
        return f"ACTIVE ({crypto_count} crypto, {stock_count} stock)"
#-------------------------------------------------------------------------------
    async def run_menu_loop(self) -> None:
        """Main menu loop"""
        while True:
            self.display_menu()
            
            try:
                choice = await self._get_user_choice()
                result = await self._handle_menu_choice(choice)
                
                if result == "exit":
                    break
                    
                await asyncio.sleep(0.1)  # Small delay to prevent console spam
                
            except KeyboardInterrupt:
                await self.stop_streams()
                break

    async def _get_user_choice(self) -> str:
        """Get user menu choice asynchronously"""
        return await asyncio.get_event_loop().run_in_executor(
            None, lambda: input().strip()
        )

    async def _handle_menu_choice(self, choice: str) -> Optional[str]:
        """Handle user menu choice"""
        if choice in self.menu_actions:
            _, action = self.menu_actions[choice]
            return await action()
        else:
            print("[!] Invalid choice!")
            return None
#-------------------------------------------------------------------------------


    async def run(self) -> None:
        """Run the complete application"""
        # Focus on configured symbols
        self.account.focus(self.config.symbols)
        
        # Start menu loop
        await self.run_menu_loop()


async def main():
    """Application entry point"""
    config = AppConfig()
    app = Menu(config)
    await app.run()


if __name__ == "__main__":
    asyncio.run(main())